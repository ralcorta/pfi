import logging
from dataclasses import dataclass
from typing import Optional, Deque
from collections import deque

import numpy as np
import tensorflow as tf

from scapy.packet import Packet, Raw
from scapy.layers.l2 import Ether
from scapy.layers.inet import IP, UDP, TCP
from scapy.layers.vxlan import VXLAN
from scapy.error import Scapy_Exception

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


@dataclass
class PacketInfo:
    src_mac: Optional[str] = None
    dst_mac: Optional[str] = None
    ethertype: Optional[int] = None
    src_ip: Optional[str] = None
    dst_ip: Optional[str] = None
    protocol: Optional[int] = None
    src_port: Optional[int] = None
    dst_port: Optional[int] = None
    payload_start: int = 0
    payload_length: int = 0

    @classmethod
    def from_packet(cls, packet: Packet) -> 'PacketInfo':
        info = cls()
        try:
            try:
                if hasattr(packet, "src"):
                    info.src_mac = str(packet.src)
                if hasattr(packet, "dst"):
                    info.dst_mac = str(packet.dst)
                if hasattr(packet, "type"):
                    info.ethertype = int(packet.type)
            except Exception:
                pass

            if IP in packet:
                ip = packet[IP]
                info.src_ip = str(getattr(ip, "src", None))
                info.dst_ip = str(getattr(ip, "dst", None))
                try:
                    info.protocol = int(getattr(ip, "proto", 0))
                except Exception:
                    info.protocol = None

                if TCP in ip:
                    t = ip[TCP]
                    try:
                        info.src_port = int(getattr(t, "sport", 0))
                        info.dst_port = int(getattr(t, "dport", 0))
                    except Exception:
                        info.src_port = info.dst_port = None
                    try:
                        info.payload_length = int(len(t.payload or b""))
                    except Exception:
                        info.payload_length = 0

                elif UDP in ip:
                    u = ip[UDP]
                    try:
                        info.src_port = int(getattr(u, "sport", 0))
                        info.dst_port = int(getattr(u, "dport", 0))
                    except Exception:
                        info.src_port = info.dst_port = None
                    try:
                        info.payload_length = int(len(u.payload or b""))
                    except Exception:
                        info.payload_length = 0
                else:
                    try:
                        info.payload_length = int(len(ip.payload or b""))
                    except Exception:
                        info.payload_length = 0
            else:
                try:
                    if Raw in packet:
                        info.payload_length = int(len(getattr(packet[Raw], "load", b"")))
                    else:
                        info.payload_length = int(len(bytes(packet.payload or b"")))
                except Exception:
                    info.payload_length = 0

            try:
                total_len = int(len(bytes(packet)))
            except Exception:
                total_len = info.payload_length
            info.payload_start = max(0, total_len - info.payload_length)

        except Exception as e:
            logger.debug(f"Error creando PacketInfo.from_packet: {e}")
        return info


@dataclass
class DetectionResult:
    is_malware: bool
    malware_probability: float
    confidence: float
    error: Optional[str] = None
    packet_info: Optional[PacketInfo] = None

    @classmethod
    def success(cls, is_malware: bool, malware_prob: float, packet_info: PacketInfo) -> 'DetectionResult':
        confidence = float(malware_prob) if is_malware else float(1.0 - malware_prob)
        return cls(
            is_malware=is_malware,
            malware_probability=float(malware_prob),
            confidence=confidence,
            packet_info=packet_info,
            error=None,
        )

    @classmethod
    def make_error(cls, error_msg: str) -> 'DetectionResult':
        return cls(
            is_malware=False,
            malware_probability=0.0,
            confidence=0.0,
            error=str(error_msg),
            packet_info=None,
        )


@dataclass
class BufferStatus:
    buffer_size: int
    required_size: int
    is_ready: bool
    buffer_fill_percentage: float


class MalwareDetector:

    def __init__(self, model_path: str, sequence_length: int = 20, payload_length: int = 1024):
        self.model_path = model_path
        self.model = None
        self.sequence_length = sequence_length
        self.payload_length = payload_length
        self.packet_buffer: Deque[np.ndarray] = deque(maxlen=self.sequence_length)

        self._load_model()

    def _load_model(self):
        try:
            if self.model_path:
                self.model = tf.keras.models.load_model(self.model_path)
                logger.info(f"Modelo cargado desde: {self.model_path}")
            else:
                logger.warning("No se proporcionó ruta de modelo; modo inferencia deshabilitado")
                self.model = None
        except Exception as e:
            logger.exception(f"Error cargando modelo: {e}")
            self.model = None

    def _to_inner_ether(self, packet_data: bytes):
        try:
            vx = VXLAN(packet_data)
            inner_bytes = None
            try:
                inner_bytes = bytes(vx.payload)
            except Exception:
                inner_bytes = None

            if inner_bytes:
                try:
                    return Ether(inner_bytes)
                except Scapy_Exception:
                    return Raw(inner_bytes)
        except Exception:
            pass

        try:
            return Ether(packet_data)
        except Scapy_Exception:
            pass

        return Raw(packet_data)

    def _parse_ethernet_packet(self, packet_data: bytes) -> Packet:
        try:
            return self._to_inner_ether(packet_data)
        except Exception as e:
            logger.debug(f"Error parsing ethernet packet: {e}")
            return Raw(packet_data)

    def _extract_payload(self, packet: Packet) -> np.ndarray:
        try:
            payload_bytes = b""

            if packet.haslayer(IP):
                ip = packet[IP]
                if ip.haslayer(TCP):
                    try:
                        payload_bytes = bytes(ip[TCP].payload or b"")
                    except Exception:
                        payload_bytes = b""
                elif ip.haslayer(UDP):
                    try:
                        payload_bytes = bytes(ip[UDP].payload or b"")
                    except Exception:
                        payload_bytes = b""
                else:
                    try:
                        payload_bytes = bytes(ip.payload or b"")
                    except Exception:
                        payload_bytes = b""
            else:
                if Raw in packet:
                    try:
                        payload_bytes = bytes(packet[Raw].load or b"")
                    except Exception:
                        payload_bytes = b""
                else:
                    try:
                        payload_bytes = bytes(packet.payload or b"")
                    except Exception:
                        payload_bytes = b""

            pl = self.payload_length
            if len(payload_bytes) >= pl:
                payload_bytes = payload_bytes[:pl]
            else:
                ba = bytearray(pl)
                ba[0:len(payload_bytes)] = payload_bytes
                payload_bytes = bytes(ba)

            arr = np.frombuffer(payload_bytes, dtype=np.uint8)
            return arr

        except Exception as e:
            logger.warning(f"Error extracting payload: {e}")
            return np.zeros(self.payload_length, dtype=np.uint8)

    def detect_malware(self, packet_data: bytes) -> Optional[DetectionResult]:
        try:
            if self.model is None:
                return DetectionResult.make_error('Modelo no cargado')

            packet = self._parse_ethernet_packet(packet_data)

            try:
                packet_info = PacketInfo.from_packet(packet)
            except Exception as e:
                logger.debug(f"Error creating PacketInfo: {e}")
                packet_info = None

            payload = self._extract_payload(packet)
            self.packet_buffer.append(payload)

            if len(self.packet_buffer) < self.sequence_length:
                return None

            sequence = np.array(list(self.packet_buffer))
            try:
                seq_reshaped = sequence.reshape(self.sequence_length, 32, 32, 1)
            except Exception as e:
                logger.exception(f"Error reshaping sequence: {e}")
                return DetectionResult.make_error(f"Error reshaping sequence: {e}")

            seq_norm = seq_reshaped.astype(np.float32) / 255.0
            model_input = seq_norm.reshape(1, *seq_norm.shape)

            try:
                pred = self.model.predict(model_input, verbose=0)
            except Exception as e:
                logger.exception(f"Error in predict(): {e}")
                return DetectionResult.make_error(f"Error en predict(): {e}")

            try:
                malware_prob = float(pred[0][0])
            except Exception as e:
                logger.exception(f"Error interpreting prediction: {e}")
                return DetectionResult.make_error(f"Error interpretando predicción: {e}")

            is_malware = malware_prob > 0.5
            
            self.packet_buffer.clear()
            
            return DetectionResult.success(is_malware, malware_prob, packet_info)

        except Exception as e:
            logger.exception(f"Error in detection: {e}")
            return DetectionResult.make_error(f"{type(e).__name__}: {e}")

    def get_buffer_status(self) -> BufferStatus:
        buffer_size = len(self.packet_buffer)
        fill_percentage = (buffer_size / self.sequence_length) * 100 if self.sequence_length else 0.0
        return BufferStatus(
            buffer_size=buffer_size,
            required_size=self.sequence_length,
            is_ready=buffer_size >= self.sequence_length,
            buffer_fill_percentage=fill_percentage
        )
    
    def clear_buffer(self):
        self.packet_buffer.clear()
        logger.info("Buffer cleared manually")
