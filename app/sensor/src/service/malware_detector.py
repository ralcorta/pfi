"""
malware_detector.py

Detector simple de malware para el sensor (versi√≥n final y robusta).

Funciones principales:
 - Normaliza paquetes entrantes (intenta VXLAN -> Ether -> Raw)
 - Extrae payload de forma defensiva y lo devuelve como numpy array (uint8)
 - Mantiene buffer secuencial para pas√°rselo a un modelo Keras
 - detect_malware(bytes) -> None | DetectionResult
"""

import logging
from dataclasses import dataclass
from typing import Optional, Deque
from collections import deque

import numpy as np
import tensorflow as tf

from scapy.packet import Packet, Raw
from scapy.layers.l2 import Ether
from scapy.layers.inet import IP, UDP, TCP
from scapy.layers.vxlan import VXLAN
from scapy.error import Scapy_Exception

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


@dataclass
class PacketInfo:
    """Informaci√≥n extra√≠da de un paquete Ethernet/Raw."""
    src_mac: Optional[str] = None
    dst_mac: Optional[str] = None
    ethertype: Optional[int] = None
    src_ip: Optional[str] = None
    dst_ip: Optional[str] = None
    protocol: Optional[int] = None
    src_port: Optional[int] = None
    dst_port: Optional[int] = None
    payload_start: int = 0
    payload_length: int = 0

    @classmethod
    def from_packet(cls, packet: Packet) -> 'PacketInfo':
        info = cls()
        try:
            # MACs / ethertype (si existen)
            try:
                if hasattr(packet, "src"):
                    info.src_mac = str(packet.src)
                if hasattr(packet, "dst"):
                    info.dst_mac = str(packet.dst)
                if hasattr(packet, "type"):
                    info.ethertype = int(packet.type)
            except Exception:
                pass

            # Si hay IP
            if IP in packet:
                ip = packet[IP]
                info.src_ip = str(getattr(ip, "src", None))
                info.dst_ip = str(getattr(ip, "dst", None))
                try:
                    info.protocol = int(getattr(ip, "proto", 0))
                except Exception:
                    info.protocol = None

                # TCP
                if TCP in ip:
                    t = ip[TCP]
                    try:
                        info.src_port = int(getattr(t, "sport", 0))
                        info.dst_port = int(getattr(t, "dport", 0))
                    except Exception:
                        info.src_port = info.dst_port = None
                    try:
                        info.payload_length = int(len(t.payload or b""))
                    except Exception:
                        info.payload_length = 0

                # UDP
                elif UDP in ip:
                    u = ip[UDP]
                    try:
                        info.src_port = int(getattr(u, "sport", 0))
                        info.dst_port = int(getattr(u, "dport", 0))
                    except Exception:
                        info.src_port = info.dst_port = None
                    try:
                        info.payload_length = int(len(u.payload or b""))
                    except Exception:
                        info.payload_length = 0
                else:
                    try:
                        info.payload_length = int(len(ip.payload or b""))
                    except Exception:
                        info.payload_length = 0
            else:
                # No-IP (Ethernet-only, ARP, LLDP, o Raw)
                try:
                    if Raw in packet:
                        info.payload_length = int(len(getattr(packet[Raw], "load", b"")))
                    else:
                        info.payload_length = int(len(bytes(packet.payload or b"")))
                except Exception:
                    info.payload_length = 0

            # payload_start: aproximaci√≥n segura
            try:
                total_len = int(len(bytes(packet)))
            except Exception:
                total_len = info.payload_length
            info.payload_start = max(0, total_len - info.payload_length)

        except Exception as e:
            logger.debug(f"‚ö†Ô∏è PacketInfo.from_packet parcial: {e}")
        return info


@dataclass
class DetectionResult:
    """Resultado de detecci√≥n de malware."""
    is_malware: bool
    malware_probability: float
    confidence: float
    error: Optional[str] = None
    packet_info: Optional[PacketInfo] = None

    @classmethod
    def success(cls, is_malware: bool, malware_prob: float, packet_info: PacketInfo) -> 'DetectionResult':
        confidence = float(malware_prob) if is_malware else float(1.0 - malware_prob)
        return cls(
            is_malware=is_malware,
            malware_probability=float(malware_prob),
            confidence=confidence,
            packet_info=packet_info,
            error=None,
        )

    @classmethod
    def make_error(cls, error_msg: str) -> 'DetectionResult':
        return cls(
            is_malware=False,
            malware_probability=0.0,
            confidence=0.0,
            error=str(error_msg),
            packet_info=None,
        )


@dataclass
class BufferStatus:
    buffer_size: int
    required_size: int
    is_ready: bool
    buffer_fill_percentage: float


class MalwareDetector:
    """Detector simple de malware (robusto frente a paquetes no est√°ndar)."""

    def __init__(self, model_path: str, sequence_length: int = 20, payload_length: int = 1024):
        self.model_path = model_path
        self.model = None
        # par√°metros del pipeline / modelo
        self.sequence_length = sequence_length
        self.payload_length = payload_length  # bytes por paquete para el extractor
        self.packet_buffer: Deque[np.ndarray] = deque(maxlen=self.sequence_length)

        # cargar modelo (si falla, self.model queda None)
        self._load_model()

    def _load_model(self):
        try:
            if self.model_path:
                self.model = tf.keras.models.load_model(self.model_path)
                logger.info(f"‚úÖ Modelo cargado desde: {self.model_path}")
            else:
                logger.warning("‚ö†Ô∏è No se proporcion√≥ ruta de modelo; modo inferencia deshabilitado")
                self.model = None
        except Exception as e:
            logger.exception(f"‚ùå Error cargando modelo: {e}")
            self.model = None

    # ----------------- Normalizaci√≥n / Decapsulaci√≥n -----------------
    def _to_inner_ether(self, packet_data: bytes):
        """
        Normaliza packet_data devolviendo:
          - Ether(...) si se puede (payload interno decapsulado)
          - Raw(...) como fallback (no rompe el pipeline)
        L√≥gica:
          1) Intentar interpretar como VXLAN (com√∫n en Traffic Mirroring).
          2) Si no, intentar Ether directo.
          3) Si falla, devolver Raw(packet_data).
        """
        # 1) Intentar VXLAN
        try:
            vx = VXLAN(packet_data)
            inner_bytes = None
            try:
                inner_bytes = bytes(vx.payload)
            except Exception:
                inner_bytes = None

            if inner_bytes:
                try:
                    return Ether(inner_bytes)
                except Scapy_Exception:
                    return Raw(inner_bytes)
        except Exception:
            # no es VXLAN o est√° truncado -> seguir
            pass

        # 2) Intentar directamente Ether
        try:
            return Ether(packet_data)
        except Scapy_Exception:
            pass

        # 3) Fallback RAW
        return Raw(packet_data)

    def _parse_ethernet_packet(self, packet_data: bytes) -> Packet:
        """Parsea y normaliza el paquete de entrada."""
        try:
            return self._to_inner_ether(packet_data)
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è _parse_ethernet_packet fallo: {e}")
            return Raw(packet_data)

    # ----------------- Extracci√≥n de payload robusta -----------------
    def _extract_payload(self, packet: Packet) -> np.ndarray:
        """
        Extrae los bytes de payload de forma defensiva y devuelve un numpy array uint8
        con longitud self.payload_length (truncado o padded con 0).
        """
        try:
            payload_bytes = b""

            # Si tiene IP
            if packet.haslayer(IP):
                ip = packet[IP]
                # TCP
                if ip.haslayer(TCP):
                    try:
                        payload_bytes = bytes(ip[TCP].payload or b"")
                    except Exception:
                        payload_bytes = b""
                # UDP
                elif ip.haslayer(UDP):
                    try:
                        payload_bytes = bytes(ip[UDP].payload or b"")
                    except Exception:
                        payload_bytes = b""
                else:
                    try:
                        payload_bytes = bytes(ip.payload or b"")
                    except Exception:
                        payload_bytes = b""
            else:
                # No IP: intentar Raw.load o payload gen√©rico
                if Raw in packet:
                    try:
                        payload_bytes = bytes(packet[Raw].load or b"")
                    except Exception:
                        payload_bytes = b""
                else:
                    try:
                        payload_bytes = bytes(packet.payload or b"")
                    except Exception:
                        payload_bytes = b""

            # Truncar o padear
            pl = self.payload_length
            if len(payload_bytes) >= pl:
                payload_bytes = payload_bytes[:pl]
            else:
                ba = bytearray(pl)
                ba[0:len(payload_bytes)] = payload_bytes
                payload_bytes = bytes(ba)

            arr = np.frombuffer(payload_bytes, dtype=np.uint8)
            return arr

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error extrayendo payload de forma robusta: {e}")
            return np.zeros(self.payload_length, dtype=np.uint8)

    # ----------------- API p√∫blica -----------------
    def detect_malware(self, packet_data: bytes) -> Optional[DetectionResult]:
        """
        Procesa bytes recibidos y devuelve:
         - None si el buffer a√∫n no lleg√≥ al tama√±o de secuencia
         - DetectionResult si se obtuvo una predicci√≥n o hubo error
        """
        try:
            if self.model is None:
                return DetectionResult.make_error('Modelo no cargado')

            # 1) Normalizar / parsear
            packet = self._parse_ethernet_packet(packet_data)

            # 2) Extraer info para logs / metadata
            try:
                packet_info = PacketInfo.from_packet(packet)
            except Exception as e:
                logger.debug(f"‚ö†Ô∏è Error creando PacketInfo: {e}")
                packet_info = None

            # 3) Extraer payload (numpy uint8)
            payload = self._extract_payload(packet)
            # Guardar en buffer circular (√∫ltimos N)
            self.packet_buffer.append(payload)

            # 4) Si el buffer a√∫n no est√° lleno, no hacemos inferencia
            if len(self.packet_buffer) < self.sequence_length:
                return None

            # 5) Preparar batch para el modelo
            sequence = np.array(list(self.packet_buffer))  # shape: (seq_len, payload_length)
            try:
                seq_reshaped = sequence.reshape(self.sequence_length, 32, 32, 1)
            except Exception as e:
                logger.exception(f"‚ùå Error reshaping sequence: {e}")
                return DetectionResult.make_error(f"Error reshaping sequence: {e}")

            seq_norm = seq_reshaped.astype(np.float32) / 255.0
            model_input = seq_norm.reshape(1, *seq_norm.shape)  # (1,20,32,32,1)

            # 6) Inferencia
            try:
                pred = self.model.predict(model_input, verbose=0)
            except Exception as e:
                logger.exception(f"‚ùå Error en predict(): {e}")
                return DetectionResult.make_error(f"Error en predict(): {e}")

            try:
                malware_prob = float(pred[0][0])
            except Exception as e:
                logger.exception(f"‚ùå Error interpretando predicci√≥n: {e}")
                return DetectionResult.make_error(f"Error interpretando predicci√≥n: {e}")

            is_malware = malware_prob > 0.5
            
            # Limpiar buffer despu√©s de la detecci√≥n para analizar nueva secuencia
            self.packet_buffer.clear()
            
            return DetectionResult.success(is_malware, malware_prob, packet_info)

        except Exception as e:
            logger.exception(f"‚ùå Error en detecci√≥n general: {e}")
            return DetectionResult.make_error(f"{type(e).__name__}: {e}")

    def get_buffer_status(self) -> BufferStatus:
        buffer_size = len(self.packet_buffer)
        fill_percentage = (buffer_size / self.sequence_length) * 100 if self.sequence_length else 0.0
        return BufferStatus(
            buffer_size=buffer_size,
            required_size=self.sequence_length,
            is_ready=buffer_size >= self.sequence_length,
            buffer_fill_percentage=fill_percentage
        )
    
    def clear_buffer(self):
        """Limpia el buffer de paquetes manualmente."""
        self.packet_buffer.clear()
        logger.info("üßπ Buffer limpiado manualmente")
